{"$message_type":"diagnostic","message":"unused import: `Rgb`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\genetics\\inheritance.rs","byte_start":125,"byte_end":128,"line_start":5,"line_end":5,"column_start":31,"column_end":34,"is_primary":true,"text":[{"text":"use crate::types::{GeneValue, Rgb};","highlight_start":31,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\genetics\\inheritance.rs","byte_start":123,"byte_end":128,"line_start":5,"line_end":5,"column_start":29,"column_end":34,"is_primary":true,"text":[{"text":"use crate::types::{GeneValue, Rgb};","highlight_start":29,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\genetics\\inheritance.rs","byte_start":113,"byte_end":114,"line_start":5,"line_end":5,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"use crate::types::{GeneValue, Rgb};","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\genetics\\inheritance.rs","byte_start":128,"byte_end":129,"line_start":5,"line_end":5,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"use crate::types::{GeneValue, Rgb};","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `Rgb`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\inheritance.rs:5:31\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use crate::types::{GeneValue, Rgb};\n  \u001b[1m\u001b[96m|\u001b[0m                               \u001b[1m\u001b[93m^^^\u001b[0m\n  \u001b[1m\u001b[96m|\u001b[0m\n  \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `Distribution` and `Standard`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\genetics\\mutation.rs","byte_start":118,"byte_end":130,"line_start":5,"line_end":5,"column_start":27,"column_end":39,"is_primary":true,"text":[{"text":"use rand::distributions::{Distribution, Standard};","highlight_start":27,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\genetics\\mutation.rs","byte_start":132,"byte_end":140,"line_start":5,"line_end":5,"column_start":41,"column_end":49,"is_primary":true,"text":[{"text":"use rand::distributions::{Distribution, Standard};","highlight_start":41,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\genetics\\mutation.rs","byte_start":92,"byte_end":144,"line_start":5,"line_end":6,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use rand::distributions::{Distribution, Standard};","highlight_start":1,"highlight_end":51},{"text":"use crate::types::{GeneValue, Rgb};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused imports: `Distribution` and `Standard`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mutation.rs:5:27\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m5\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use rand::distributions::{Distribution, Standard};\n  \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[93m^^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[93m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `std::collections::HashMap`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\simulation\\mod.rs","byte_start":290,"byte_end":315,"line_start":15,"line_end":15,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\simulation\\mod.rs","byte_start":286,"byte_end":318,"line_start":15,"line_end":16,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":31},{"text":"use crate::types::TurtleStats;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `std::collections::HashMap`\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\mod.rs:15:5\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use std::collections::HashMap;\n   \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `pyo3::prelude::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\types.rs","byte_start":45,"byte_end":61,"line_start":3,"line_end":3,"column_start":5,"column_end":21,"is_primary":true,"text":[{"text":"use pyo3::prelude::*;","highlight_start":5,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\types.rs","byte_start":41,"byte_end":64,"line_start":3,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use pyo3::prelude::*;","highlight_start":1,"highlight_end":22},{"text":"use serde::{Deserialize, Serialize};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: unused import: `pyo3::prelude::*`\u001b[0m\n \u001b[1m\u001b[96m--> \u001b[0msrc\\types.rs:3:5\n  \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m3\u001b[0m \u001b[1m\u001b[96m|\u001b[0m use pyo3::prelude::*;\n  \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[93m^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":1428,"byte_end":1429,"line_start":51,"line_end":51,"column_start":48,"column_end":49,"is_primary":true,"text":[{"text":"    pub fn inherit(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {","highlight_start":48,"highlight_end":49}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:51:48\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m51\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn inherit(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":1446,"byte_end":1447,"line_start":51,"line_end":51,"column_start":66,"column_end":67,"is_primary":true,"text":[{"text":"    pub fn inherit(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {","highlight_start":66,"highlight_end":67}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:51:66\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m51\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn inherit(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                                  \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":1809,"byte_end":1810,"line_start":59,"line_end":59,"column_start":56,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn inherit_blended(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {","highlight_start":56,"highlight_end":57}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:59:56\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn inherit_blended(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                        \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":1827,"byte_end":1828,"line_start":59,"line_end":59,"column_start":74,"column_end":75,"is_primary":true,"text":[{"text":"    pub fn inherit_blended(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {","highlight_start":74,"highlight_end":75}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:59:74\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m59\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn inherit_blended(&self, py: Python, parent1: &PyDict, parent2: &PyDict) -> PyResult<PyObject> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                                          \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":2182,"byte_end":2183,"line_start":67,"line_end":67,"column_start":48,"column_end":49,"is_primary":true,"text":[{"text":"    pub fn mutate(&self, py: Python, genetics: &PyDict, rate: f32) -> PyResult<PyObject> {","highlight_start":48,"highlight_end":49}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:67:48\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m67\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn mutate(&self, py: Python, genetics: &PyDict, rate: f32) -> PyResult<PyObject> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":2494,"byte_end":2495,"line_start":74,"line_end":74,"column_start":41,"column_end":42,"is_primary":true,"text":[{"text":"    pub fn similarity(&self, genetics1: &PyDict, genetics2: &PyDict) -> PyResult<f32> {","highlight_start":41,"highlight_end":42}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:74:41\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn similarity(&self, genetics1: &PyDict, genetics2: &PyDict) -> PyResult<f32> {\n    \u001b[1m\u001b[96m|\u001b[0m                                         \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":2514,"byte_end":2515,"line_start":74,"line_end":74,"column_start":61,"column_end":62,"is_primary":true,"text":[{"text":"    pub fn similarity(&self, genetics1: &PyDict, genetics2: &PyDict) -> PyResult<f32> {","highlight_start":61,"highlight_end":62}],"label":"the trait `PyClass` is not implemented for `&PyDict`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `PyClass`:\n  PyGenetics\n  PyRace\n  PyTurtle","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObject<'_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `extract_argument`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3278,"byte_end":3294,"line_start":113,"line_end":113,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn extract_argument<'a, 'py, T>(","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs","byte_start":3421,"byte_end":3448,"line_start":119,"line_end":119,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: PyFunctionArgument<'a, 'py>,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `extract_argument`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&PyDict: PyFunctionArgument<'_, '_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:74:61\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m74\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     pub fn similarity(&self, genetics1: &PyDict, genetics2: &PyDict) -> PyResult<f32> {\n    \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mthe trait `PyClass` is not implemented for `&PyDict`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mhelp\u001b[0m: the following other types implement trait `PyClass`:\n              PyGenetics\n              PyRace\n              PyTurtle\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObject<'_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `FromPyObjectBound<'_, '_>`\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `&PyDict` to implement `PyFunctionArgument<'_, '_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `extract_argument`\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-0.23.5\\src\\impl_\\extract_argument.rs:119:8\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m113\u001b[0m \u001b[1m\u001b[96m|\u001b[0m pub fn extract_argument<'a, 'py, T>(\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[96m----------------\u001b[0m \u001b[1m\u001b[96mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m119\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     T: PyFunctionArgument<'a, 'py>,\n    \u001b[1m\u001b[96m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `extract_argument`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `iter` found for reference `&PyDict` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":2968,"byte_end":2972,"line_start":86,"line_end":86,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"        for (key, value) in dict.iter() {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `iter_tag` with a similar name","code":null,"level":"help","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":2968,"byte_end":2972,"line_start":86,"line_end":86,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"        for (key, value) in dict.iter() {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":"iter_tag","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `iter` found for reference `&PyDict` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:86:34\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         for (key, value) in dict.iter() {\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `iter_tag` with a similar name\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        for (key, value) in dict.iter\u001b[92m_tag\u001b[0m() {\n   \u001b[1m\u001b[96m|\u001b[0m                                      \u001b[92m++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":3012,"byte_end":3015,"line_start":87,"line_end":87,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"            let key_str: String = key.extract()?;","highlight_start":35,"highlight_end":38}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:87:35\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m87\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let key_str: String = key.extract()?;\n   \u001b[1m\u001b[96m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src\\genetics\\mod.rs","byte_start":3293,"byte_end":3298,"line_start":93,"line_end":93,"column_start":51,"column_end":56,"is_primary":true,"text":[{"text":"                        let tuple: (u8, u8, u8) = value.extract()?;","highlight_start":51,"highlight_end":56}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m\u001b[97m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\genetics\\mod.rs:93:51\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m93\u001b[0m \u001b[1m\u001b[96m|\u001b[0m                         let tuple: (u8, u8, u8) = value.extract()?;\n   \u001b[1m\u001b[96m|\u001b[0m                                                   \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `pyo3::IntoPy::into_py`: `IntoPy` is going to be replaced by `IntoPyObject`. See the migration guide (https://pyo3.rs/v0.23.0/migration) for more information.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src\\simulation\\mod.rs","byte_start":3684,"byte_end":3691,"line_start":145,"line_end":145,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"        Ok(positions.into_py(py))","highlight_start":22,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[93mwarning\u001b[0m\u001b[1m\u001b[97m: use of deprecated method `pyo3::IntoPy::into_py`: `IntoPy` is going to be replaced by `IntoPyObject`. See the migration guide (https://pyo3.rs/v0.23.0/migration) for more information.\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\mod.rs:145:22\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m145\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         Ok(positions.into_py(py))\n    \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[93m^^^^^^^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"no method named `add_class` found for reference `&pyo3::types::PyModule` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":585,"byte_end":594,"line_start":22,"line_end":22,"column_start":7,"column_end":16,"is_primary":true,"text":[{"text":"    m.add_class::<PyGenetics>()?;","highlight_start":7,"highlight_end":16}],"label":"method not found in `&pyo3::types::PyModule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `add_class` found for reference `&pyo3::types::PyModule` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:22:7\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m22\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     m.add_class::<PyGenetics>()?;\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&pyo3::types::PyModule`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `add_class` found for reference `&pyo3::types::PyModule` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":620,"byte_end":629,"line_start":23,"line_end":23,"column_start":7,"column_end":16,"is_primary":true,"text":[{"text":"    m.add_class::<PyTurtle>()?;","highlight_start":7,"highlight_end":16}],"label":"method not found in `&pyo3::types::PyModule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `add_class` found for reference `&pyo3::types::PyModule` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:23:7\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m23\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     m.add_class::<PyTurtle>()?;\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&pyo3::types::PyModule`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `add_class` found for reference `&pyo3::types::PyModule` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":653,"byte_end":662,"line_start":24,"line_end":24,"column_start":7,"column_end":16,"is_primary":true,"text":[{"text":"    m.add_class::<PyRace>()?;","highlight_start":7,"highlight_end":16}],"label":"method not found in `&pyo3::types::PyModule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `add_class` found for reference `&pyo3::types::PyModule` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:24:7\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m24\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     m.add_class::<PyRace>()?;\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&pyo3::types::PyModule`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `add` found for reference `&pyo3::types::PyModule` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":711,"byte_end":714,"line_start":27,"line_end":27,"column_start":7,"column_end":10,"is_primary":true,"text":[{"text":"    m.add(\"__version__\", \"0.1.0\")?;","highlight_start":7,"highlight_end":10}],"label":"method not found in `&pyo3::types::PyModule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m\u001b[97m: no method named `add` found for reference `&pyo3::types::PyModule` in the current scope\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:27:7\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m27\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     m.add(\"__version__\", \"0.1.0\")?;\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&pyo3::types::PyModule`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&pyo3::types::PyModule: From<BoundRef<'_, '_, pyo3::types::PyModule>>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":500,"byte_end":511,"line_start":20,"line_end":20,"column_start":1,"column_end":12,"is_primary":true,"text":[{"text":"#[pymodule]","highlight_start":1,"highlight_end":12}],"label":"the trait `From<BoundRef<'_, '_, pyo3::types::PyModule>>` is not implemented for `&pyo3::types::PyModule`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\lib.rs","byte_start":500,"byte_end":511,"line_start":20,"line_end":20,"column_start":1,"column_end":12,"is_primary":false,"text":[{"text":"#[pymodule]","highlight_start":1,"highlight_end":12}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[pymodule]","def_site_span":{"file_name":"C:\\Users\\cheat\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\pyo3-macros-0.23.5\\src\\lib.rs","byte_start":2058,"byte_end":2127,"line_start":40,"line_end":40,"column_start":1,"column_end":70,"is_primary":false,"text":[{"text":"pub fn pymodule(args: TokenStream, input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"required for `BoundRef<'_, '_, pyo3::types::PyModule>` to implement `Into<&pyo3::types::PyModule>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m\u001b[97m: the trait bound `&pyo3::types::PyModule: From<BoundRef<'_, '_, pyo3::types::PyModule>>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\lib.rs:20:1\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m20\u001b[0m \u001b[1m\u001b[96m|\u001b[0m #[pymodule]\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<BoundRef<'_, '_, pyo3::types::PyModule>>` is not implemented for `&pyo3::types::PyModule`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: required for `BoundRef<'_, '_, pyo3::types::PyModule>` to implement `Into<&pyo3::types::PyModule>`\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: this error originates in the attribute macro `pymodule` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `*self` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src\\simulation\\race.rs","byte_start":1284,"byte_end":1288,"line_start":49,"line_end":49,"column_start":27,"column_end":31,"is_primary":true,"text":[{"text":"            let terrain = self.get_terrain_at(turtle.race_distance).clone();","highlight_start":27,"highlight_end":31}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\race.rs","byte_start":1147,"byte_end":1164,"line_start":44,"line_end":44,"column_start":23,"column_end":40,"is_primary":false,"text":[{"text":"        for turtle in &mut self.turtles {","highlight_start":23,"highlight_end":40}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\simulation\\race.rs","byte_start":1147,"byte_end":1164,"line_start":44,"line_end":44,"column_start":23,"column_end":40,"is_primary":false,"text":[{"text":"        for turtle in &mut self.turtles {","highlight_start":23,"highlight_end":40}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\simulation\\race.rs","byte_start":1147,"byte_end":1164,"line_start":44,"line_end":44,"column_start":23,"column_end":40,"is_primary":false,"text":[{"text":"        for turtle in &mut self.turtles {","highlight_start":23,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m\u001b[97m: cannot borrow `*self` as immutable because it is also borrowed as mutable\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0msrc\\simulation\\race.rs:49:27\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m44\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         for turtle in &mut self.turtles {\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96m-----------------\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96mmutable borrow occurs here\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                       \u001b[1m\u001b[96mmutable borrow later used here\u001b[0m\n\u001b[1m\u001b[96m...\u001b[0m\n\u001b[1m\u001b[96m49\u001b[0m \u001b[1m\u001b[96m|\u001b[0m             let terrain = self.get_terrain_at(turtle.race_distance).clone();\n   \u001b[1m\u001b[96m|\u001b[0m                           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 16 previous errors; 5 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 16 previous errors; 5 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0502, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mSome errors have detailed explanations: E0277, E0282, E0502, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
